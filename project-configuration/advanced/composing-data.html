<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta content='IE=edge' http-equiv=X-UA-Compatible> <meta content='width=device-width, initial-scale=1' name=viewport> <title>Composing JSON Data - Cider-Ci Documentation</title> <link href="../../assets/stylesheets/app-b5c8715a.css" rel=stylesheet /> <script src="../../assets/javascripts/vendor-1e8b60d8.js"></script> <script src="../../assets/javascripts/app-871935e9.js"></script> </head> <body id=the-cider-ci-documentation> <div class=container> <nav class='navbar navbar-inverse'> <div class=container-fluid> <div class=navbar-header> <a class=navbar-brand href="../../">Cider-CI Documentation </a></div> <form action='/search.html' class='navbar-form navbar-left' id=search method=get role=search> <div class=form-group> <input class=form-control id=search-term name=term placeholder=Search> <button class='btn btn-default' style='display: none' type=submit>Submit</button> </div> </form> <ul class='nav navbar-nav'> <li> <a href="../../introduction/">Introduction </a></li> <li> <a href="../../introduction/quick-start/">Quick-Start </a></li> <li> <a href="../../sitemap.html">Sitemap </a></li> </ul> </div> </nav> <div class=row> <div class=col-md-6> <ol class=breadcrumb> <li> <a href="../../">Home </a></li> <li> <a href="../">Project Configuration </a></li> <li> <a href="./">Advanced Topics </a></li> <li> <a href="composing-data.html">Composing Data </a></li> </ol> </div> <div class=col-md-6> </div> </div> <div class=content> <h1 id=composing-json-data>Composing JSON Data</h1> <p>We wish to <strong>achieve composability</strong> and <strong>avoid repetition</strong> when specifying "things" to be "done". Cider-CI provides the <a href="inheritance.html">inheritance</a> and means to <a href="sharing-data.html">sharing data</a> to achieve this. Both require a mechanism to merge data. This page discusses the inner workings of this.</p> <div class=row> <div class=col-md-6> <p>The project configuration is encoded in JSON format. JSON provides maps, arrays and some primitive types. The obvious solution when composing JSON data is to use some kind of <em>"recursive merging"</em>. This works well for maps. But it is impossible to specify a general merging strategy for arrays. Arrays are ordered and provide indexes. A meaningful composition must consider the means of the data in the array to produce a sensible composition.</p> <p>We avoid the overhead of considering semantics of arrays by <strong>favoring maps</strong> in the project configuration of Cider-CI. Whenever some <em>set</em>, or <em>collection</em> like structure is the natural encoding for some entities we will use a map. The following extract gives a simple example.</p> </div> <div class=col-md-6> <div class="language-yaml highlighter-coderay"><div class=CodeRay> <div class=code><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#606">scripts</span>:
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  <span style="color:#606">prepare</span>:
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span style="color:#606">body</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">do some preparing</span></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  <span style="color:#606">test</span>:
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    <span style="color:#606">body</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">test</span></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    <span style="color:#606">start_when</span>:
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      <span style="color:#606"><span style="color:#404">'</span><span>prepared</span><span style="color:#404">'</span></span>:
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        <span style="color:#606">script_key</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">prepare</span></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        <span style="color:#606">states</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">[ &quot;passed&quot; ]</span></span>
</pre></div> </div> </div> <p>Here the contents of <code>scripts</code> and <code>start_when</code> could have been arrays. In the case of scripts the keys are important to be used as reference.</p> </div> </div> <h2 id=the-deep-merge-strategy>The Deep-Merge Strategy</h2> <div class=row> <div class=col-md-6> <p>The canonical definition of <em>deep-merge</em> is mnemonic and easy to understand. The following almost formal definition will help to clarify doubts.</p> <h3 id=definition>Definition</h3> <p>Let <code>m1</code> and <code>m2</code> be a maps, and let <code>m</code> be the result of <code>(m1 deep-merge m2)</code> Then the following holds true:</p> <ol> <li> <p>If the key <code>k1</code> with the value <code>v1</code> is present in <code>m1</code> but not in <code>m2</code>, then the key value pair <code>(k1,v1)</code> is be present in <code>m</code>.</p> </li> <li> <p>If the key <code>k2</code> with the value <code>v2</code> is present in <code>m2</code> but not in <code>m1</code>, then the key value pair <code>(k2,v2)</code> is be present in <code>m</code>.</p> </li> <li> <p>If <code>k</code> is present in <code>m1</code> and <code>m2</code></p> <ol> <li> <p>and <code>v1</code> and <code>v2</code> are both maps, then the pair <code>(k, ( v1 deep-merge v2))</code> is present in <code>m</code>.</p> </li> <li> <p>otherwise the pair <code>(k,v2)</code> is present in <code>m</code>.</p> </li> </ol> </li> </ol> </div> <div class=col-md-6> <h3 id=structural-properties>Structural Properties</h3> <p>We expand into some structural properties of deep-merge. It is not important to understand following but it deepens the understanding and emphasizes the composability of the chosen method in Cider-CI to aggregate JSON data.</p> <p>Let <code>S</code> be the set of all JSON encoded data which has a map as its top level data structure, let <code>{}</code> denote the empty map, and <code>⊕</code> the shorthand symbol for <code>deep-merge</code>. Then <code>(a ⊕ (b ⊕ c)) = (a ⊕ b) ⊕ c)) ∈ S</code> and <code>(a ⊕ {}) = ({} ⊕ a) = a</code> for all <code>a, b, c ∈ S</code>. In other words: the <code>deep-merge</code> operation and the set of all maps in JSON form a <strong><a href="https://en.wikipedia.org/wiki/Monoid">monoid</a></strong> <code>(S,{},⊕)</code>. However, it is clearly <strong>not commutative</strong> and there exists only the trivial inverse element <code>{}</code>.</p> </div> </div> </div> <div class=row> <div class=col-md-12> <footer> <div class=pull-right> Cider-CI <span class=semantic-version><span class=major>4</span><span class=divider>.</span><span class=minor>1</span><span class=patch-pre-build><span class=divider>.</span><span class=patch>0</span><span class=divider>-</span><span class=pre>0.0</span></span></span> Documentation 2016-07-24 © Thomas Schank and contributors </div> </footer> </div> </div> </div> </body> </html>